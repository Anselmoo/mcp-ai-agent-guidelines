# Copilot Project Instructions

This is a TypeScript-based MCP (Model Context Protocol) server providing AI agent guidelines and development tools. It is primarily responsible for providing structured prompts, code analysis, and design assistance tools. Please follow these guidelines when contributing:

## Using These Instructions

These instructions help GitHub Copilot and other AI coding assistants understand the project structure, conventions, and workflows. When working on tasks:

- **Well-suited for AI assistance**: Bug fixes, test coverage improvements, documentation updates, refactoring for clarity, adding new tools following existing patterns, updating dependencies
- **Requires human expertise**: Major architectural changes, complex business logic, security-critical features, ambiguous requirements
- **Always verify**: Lint, build, and test your changes early and often. Use `npm run quality` before committing.

## 1. Overview & Architecture

- **Entry Point**: `src/index.ts` is the declarative entry point, wiring up the MCP server and its tool handlers. Avoid putting business logic here.
- **Tool Structure**: All tools are located in `src/tools/` and organized by category (e.g., `design`, `analysis`, `prompt`). Each tool is a self-contained module.
- **Central Orchestrator**: The `design-assistant.ts` in `src/tools/design/` is a critical component that coordinates many other services like `constraint-manager.ts` and `methodology-selector.ts`. When working on design-related features, start by understanding its role as a facade.
- **Deterministic Exports**: The project uses barrel files (`index.ts` in subdirectories) to aggregate and export modules. When adding a new tool, prompt, or resource, ensure it is exported from the appropriate barrel file.
- **Demos**: The `demos/` directory contains scripts (`*.js`) that demonstrate tool functionality and act as regression tests. After making changes to a tool, consider updating or regenerating the corresponding demo by running `node demos/demo-tools.js`.

### Repository Structure
- `src/` - TypeScript source code
  - `src/index.ts` - MCP server entry point and tool registration
  - `src/tools/` - Tool implementations organized by category (design, analysis, prompt, etc.)
  - `src/resources/` - Static resources and structured data
  - `src/prompts/` - Prompt templates and builders
- `tests/` - Test files and utilities
  - `tests/vitest/` - Vitest test suite (mirrors src/ structure)
  - `tests/unit/` - Additional unit tests
- `demos/` - Demo scripts (`*.js`) and generated artifacts (`*.md`)
- `scripts/` - Build, test, and utility scripts
- `.github/` - CI workflows, issue templates, and this instructions file
- `dist/` - Compiled JavaScript output (generated by `npm run build`)
- `coverage/` - Test coverage reports (generated by coverage commands)

## 2. Coding Conventions & Patterns

- **Strict TypeScript & ESM**: The project uses strict TypeScript and pure ES Modules. All relative imports **must** end with `.js` as per ESM requirements (e.g., `import { a } from './b.js';`).
- **Input Validation**: All tool inputs are strictly parsed using `zod` schemas. When adding or modifying a tool, ensure its input schema is robust.
- **State Management**: Shared state is managed by singletons (e.g., `constraintManager`, `crossSessionConsistencyEnforcer`). Always reuse these existing instances instead of creating new ones.
- **Immutability**: Strive for functional purity in modules. Avoid direct state mutations where possible.

## 3. Build, Test, and Quality Workflow

### Required Before Each Commit
- Run `npm run quality` before committing any changes to ensure code quality
- This performs TypeScript type-checking and Biome linting/formatting
- Alternatively, run `npx lefthook run pre-commit` to execute the same checks

### Development Flow
- **Install dependencies**: `npm ci`
- **Build**: `npm run build` (compiles TypeScript to `dist/`)
- **Test**: `npm run test:all` (runs all tests: unit, integration, demo, MCP)
- **Quality check**: `npm run quality` (TypeScript type-check + Biome linter/formatter)
- **Full validation**: `npm run validate` (lint + type-check + all tests)

### Specific Test Commands
- `npm run test:vitest`: Primary test suite using Vitest
- `npm run test:unit`: Unit tests only
- `npm run test:integration`: Integration tests
- `npm run test:demo`: Demo scripts validation
- `npm run test:coverage:vitest`: Generate coverage report in `coverage/`

### Linting and Formatting
- `npm run check`: Run Biome check on source files
- `npm run check:fix`: Auto-fix Biome issues
- `npm run lint`: Lint source files
- `npm run lint:fix`: Auto-fix linting issues
- `npm run type-check`: TypeScript type checking without emitting files

### Git Hooks (Lefthook)
The project uses `lefthook` (configured in `lefthook.yml`) to enforce quality gates:
- **`pre-commit`**: Runs fast checks like formatting (Biome) and type-checking (`tsc --noEmit`)
- **`pre-push`**: Runs the full quality and test pipeline (`npm run quality` and `npm run test:all`)
- **Your changes must pass these hooks to be committed and pushed**
- Run manually: `npx lefthook run pre-commit` or `npx lefthook run pre-push`

## 4. Testing Patterns

- **Target Public APIs**: Write tests against the exported functions and classes, not internal implementation details. See `tests/vitest/unit/design-*.spec.ts` for examples.
- **Fixtures**: Create minimal, inline test fixtures. Do not rely on large, shared fixture files.
- **Spies and Mocks**: Use Vitest's `vi.spyOn()` to mock dependencies and observe function calls, as shown in `tests/vitest/design-assistant-consistency-integration.test.ts`.
- **Test Location**: Test files in `tests/vitest/` should mirror the `src/` directory structure to make them easy to find.

## 5. Extending the Project

- **Adding a Tool**:
  1. Create the new tool file under the appropriate category in `src/tools/`.
  2. Export the tool's handler from the category's `index.ts` barrel file.
  3. Register the tool handler in `src/index.ts`.
  4. Add a corresponding `.spec.ts` file in `tests/vitest/tools/` following the same directory structure.
- **Adding a Prompt or Resource**:
  1. Create the file in `src/prompts` or `src/resources`.
  2. Add it to the aggregator in `src/prompts/index.ts` or `src/resources/index.ts`. This ensures it's included in the static MCP manifest.

## 6. Key Guidelines

1. **Follow TypeScript best practices** and maintain strict type safety
2. **Use ESM imports** with `.js` extensions for all relative imports
3. **Maintain existing code structure** and organization patterns
4. **Write tests for new functionality** - prefer Vitest, mirror `src/` structure in `tests/vitest/`
5. **Document public APIs** and complex logic with clear comments
6. **Run quality checks before committing** - `npm run quality` or `npx lefthook run pre-commit`
7. **Update demos when modifying tools** - regenerate with `node demos/demo-tools.js`
8. **Keep barrel files updated** - export new modules from appropriate `index.ts` files
9. **Use zod for input validation** - ensure robust schema definitions for all tool inputs
10. **Reuse singleton instances** - don't create new instances of shared services

_If any of these instructions are unclear or seem incomplete, please ask for clarification!_
