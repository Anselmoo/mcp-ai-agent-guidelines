# T-037: Implement Framework Router

**Task ID**: T-037
**Phase**: 3 - Consolidation
**Priority**: P0 (Critical Path)
**Estimate**: 8 hours
**Owner**: @mcp-tool-builder
**Reviewer**: @architecture-advisor
**Dependencies**: T-011 through T-016 (all strategies migrated)
**Blocks**: T-038 (cross-cutting), T-039 (output formats)

---

## 1. Overview

### What

Create a unified **Framework Router** that:
- Routes requests to the appropriate strategy based on `OutputApproach`
- Manages strategy lifecycle (instantiation, caching, cleanup)
- Provides a single entry point for all output generation
- Enables cross-cutting capabilities (diagrams, shell scripts, configs)

### Why

Current state:
- Each strategy instantiated separately in tool handlers
- No unified routing logic
- Cross-cutting capabilities duplicated
- Hard to add new output approaches

Target state:
- Single `FrameworkRouter.execute(approach, input)` API
- Strategy caching for performance
- Plugin architecture for cross-cutting capabilities
- Easy to add new output approaches

### Architecture

```
┌─────────────────────────────────────────────────────────────┐
│                     MCP Tool Handler                        │
│  (speckit-generator, togaf-generator, adr-generator, etc.) │
└─────────────────────────────┬───────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                     FrameworkRouter                         │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐         │
│  │ Strategy    │  │ Plugin      │  │ Output      │         │
│  │ Registry    │  │ Manager     │  │ Formatter   │         │
│  └──────┬──────┘  └──────┬──────┘  └──────┬──────┘         │
└─────────┼────────────────┼────────────────┼─────────────────┘
          │                │                │
          ▼                ▼                ▼
┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐
│ SpecKitStrategy │ │ DiagramPlugin   │ │ MarkdownFormat  │
│ TOGAFStrategy   │ │ ShellPlugin     │ │ JSONFormat      │
│ ADRStrategy     │ │ ConfigPlugin    │ │ HTMLFormat      │
│ RFCStrategy     │ │ IssuesPlugin    │ │                 │
│ ...             │ │ ...             │ │                 │
└─────────────────┘ └─────────────────┘ └─────────────────┘
```

---

## 2. Implementation Guide

### Step 2.1: Define Router Types

```typescript
// src/domain/router/types.ts

import type { StrategyResult } from '../base-strategy/types.js';

/**
 * Output approaches supported by the router.
 * Maps to strategy implementations.
 */
export type OutputApproach =
  | 'speckit'
  | 'togaf'
  | 'adr'
  | 'rfc'
  | 'enterprise'
  | 'sdd'
  | 'chat';

/**
 * Cross-cutting capabilities that can be added to any output.
 */
export type CrossCuttingCapability =
  | 'workflow'       // GitHub Actions, CI/CD
  | 'shell-script'   // Bash/PowerShell scripts
  | 'diagram'        // Mermaid diagrams
  | 'config'         // Config file generation
  | 'issues'         // GitHub issue templates
  | 'pr-template';   // Pull request templates

/**
 * Router request - what MCP tools send to the router.
 */
export interface RouterRequest<TInput = unknown> {
  /** Which output approach to use */
  approach: OutputApproach;

  /** Input data for the strategy */
  input: TInput;

  /** Optional cross-cutting capabilities to enable */
  capabilities?: CrossCuttingCapability[];

  /** Output format preference */
  format?: OutputFormat;

  /** Request metadata */
  metadata?: {
    requestId?: string;
    correlationId?: string;
    timeout?: number;
  };
}

/**
 * Router response - what the router returns to MCP tools.
 */
export interface RouterResponse<TOutput = unknown> {
  /** Whether execution succeeded */
  success: boolean;

  /** Strategy output (if success) */
  output?: TOutput;

  /** Cross-cutting outputs (diagrams, scripts, etc.) */
  artifacts?: CrossCuttingArtifacts;

  /** Error information (if failure) */
  error?: RouterError;

  /** Execution trace for debugging */
  trace: ExecutionSummary;
}

/**
 * Artifacts generated by cross-cutting plugins.
 */
export interface CrossCuttingArtifacts {
  diagrams?: DiagramArtifact[];
  scripts?: ScriptArtifact[];
  configs?: ConfigArtifact[];
  workflows?: WorkflowArtifact[];
  issues?: IssueArtifact[];
}

export interface DiagramArtifact {
  name: string;
  type: 'mermaid' | 'plantuml' | 'graphviz';
  content: string;
}

export interface ScriptArtifact {
  name: string;
  platform: 'bash' | 'powershell' | 'cross-platform';
  content: string;
}

export interface ConfigArtifact {
  name: string;
  format: 'json' | 'yaml' | 'toml';
  content: string;
}

export interface WorkflowArtifact {
  name: string;
  platform: 'github' | 'gitlab' | 'azure';
  content: string;
}

export interface IssueArtifact {
  title: string;
  body: string;
  labels: string[];
}

/**
 * Supported output formats.
 */
export type OutputFormat = 'markdown' | 'json' | 'html' | 'yaml';

/**
 * Router error with categorization.
 */
export interface RouterError {
  code: RouterErrorCode;
  message: string;
  approach?: OutputApproach;
  cause?: Error;
}

export type RouterErrorCode =
  | 'UNKNOWN_APPROACH'
  | 'STRATEGY_NOT_FOUND'
  | 'VALIDATION_FAILED'
  | 'EXECUTION_FAILED'
  | 'PLUGIN_FAILED'
  | 'FORMAT_FAILED'
  | 'TIMEOUT';

/**
 * Summary of execution for tracing.
 */
export interface ExecutionSummary {
  requestId: string;
  approach: OutputApproach;
  startedAt: Date;
  completedAt: Date;
  durationMs: number;
  strategyVersion: string;
  pluginsExecuted: string[];
  metrics: Record<string, number>;
}
```

### Step 2.2: Implement Strategy Registry

```typescript
// src/domain/router/strategy-registry.ts

import type { BaseStrategy } from '../base-strategy/index.js';
import type { OutputApproach } from './types.js';

/**
 * Factory function that creates a strategy instance.
 */
type StrategyFactory<TInput, TOutput> = () => BaseStrategy<TInput, TOutput>;

/**
 * Registry entry with metadata.
 */
interface RegistryEntry {
  factory: StrategyFactory<unknown, unknown>;
  version: string;
  description: string;
  singleton: boolean;
  instance?: BaseStrategy<unknown, unknown>;
}

/**
 * Strategy Registry - manages strategy registration and instantiation.
 *
 * Features:
 * - Lazy instantiation for performance
 * - Singleton support for stateless strategies
 * - Version tracking for debugging
 *
 * @example
 * ```typescript
 * const registry = new StrategyRegistry();
 *
 * // Register strategies
 * registry.register('speckit', () => new SpecKitStrategy(), {
 *   version: '2.0.0',
 *   description: 'Generate project specification artifacts',
 *   singleton: true,
 * });
 *
 * // Get strategy instance
 * const strategy = registry.get('speckit');
 * ```
 */
export class StrategyRegistry {
  private readonly strategies = new Map<OutputApproach, RegistryEntry>();

  /**
   * Register a strategy factory.
   *
   * @param approach - The output approach this strategy handles
   * @param factory - Factory function to create strategy instances
   * @param options - Registration options
   */
  register<TInput, TOutput>(
    approach: OutputApproach,
    factory: StrategyFactory<TInput, TOutput>,
    options: {
      version: string;
      description: string;
      singleton?: boolean;
    }
  ): void {
    if (this.strategies.has(approach)) {
      throw new Error(`Strategy already registered for approach: ${approach}`);
    }

    this.strategies.set(approach, {
      factory: factory as StrategyFactory<unknown, unknown>,
      version: options.version,
      description: options.description,
      singleton: options.singleton ?? true,
    });
  }

  /**
   * Get a strategy instance for an approach.
   *
   * @param approach - The output approach
   * @returns Strategy instance
   * @throws If no strategy registered for approach
   */
  get<TInput, TOutput>(approach: OutputApproach): BaseStrategy<TInput, TOutput> {
    const entry = this.strategies.get(approach);

    if (!entry) {
      throw new Error(`No strategy registered for approach: ${approach}`);
    }

    // Return cached instance for singletons
    if (entry.singleton) {
      if (!entry.instance) {
        entry.instance = entry.factory();
      }
      return entry.instance as BaseStrategy<TInput, TOutput>;
    }

    // Create new instance for non-singletons
    return entry.factory() as BaseStrategy<TInput, TOutput>;
  }

  /**
   * Check if an approach is registered.
   */
  has(approach: OutputApproach): boolean {
    return this.strategies.has(approach);
  }

  /**
   * Get metadata for all registered strategies.
   */
  list(): Array<{
    approach: OutputApproach;
    version: string;
    description: string;
  }> {
    return Array.from(this.strategies.entries()).map(([approach, entry]) => ({
      approach,
      version: entry.version,
      description: entry.description,
    }));
  }

  /**
   * Clear all registered strategies (for testing).
   */
  clear(): void {
    this.strategies.clear();
  }
}

/**
 * Default singleton instance.
 */
export const strategyRegistry = new StrategyRegistry();
```

### Step 2.3: Implement Plugin Manager

```typescript
// src/domain/router/plugin-manager.ts

import type { CrossCuttingCapability, CrossCuttingArtifacts } from './types.js';

/**
 * Plugin interface - all cross-cutting plugins must implement this.
 */
export interface CrossCuttingPlugin {
  /** Plugin identifier */
  readonly name: CrossCuttingCapability;

  /** Plugin version */
  readonly version: string;

  /**
   * Execute the plugin on strategy output.
   *
   * @param strategyOutput - Output from the main strategy
   * @param context - Execution context with metadata
   * @returns Generated artifacts
   */
  execute<T>(
    strategyOutput: T,
    context: PluginContext
  ): Promise<PluginResult>;
}

/**
 * Context provided to plugins during execution.
 */
export interface PluginContext {
  approach: string;
  requestId: string;
  metadata: Record<string, unknown>;
}

/**
 * Result from plugin execution.
 */
export interface PluginResult {
  success: boolean;
  artifacts?: Partial<CrossCuttingArtifacts>;
  error?: Error;
}

/**
 * Plugin Manager - manages cross-cutting capability plugins.
 *
 * Plugins can:
 * - Generate Mermaid diagrams from strategy output
 * - Create shell scripts for automation
 * - Generate config files
 * - Create GitHub workflow files
 * - Generate issue templates
 *
 * @example
 * ```typescript
 * const manager = new PluginManager();
 *
 * // Register plugins
 * manager.register(new DiagramPlugin());
 * manager.register(new ShellScriptPlugin());
 *
 * // Execute selected plugins
 * const artifacts = await manager.execute(
 *   ['diagram', 'shell-script'],
 *   strategyOutput,
 *   context
 * );
 * ```
 */
export class PluginManager {
  private readonly plugins = new Map<CrossCuttingCapability, CrossCuttingPlugin>();

  /**
   * Register a plugin.
   */
  register(plugin: CrossCuttingPlugin): void {
    if (this.plugins.has(plugin.name)) {
      throw new Error(`Plugin already registered: ${plugin.name}`);
    }
    this.plugins.set(plugin.name, plugin);
  }

  /**
   * Execute selected plugins on strategy output.
   *
   * @param capabilities - Which plugins to execute
   * @param strategyOutput - Output from main strategy
   * @param context - Execution context
   * @returns Combined artifacts from all plugins
   */
  async execute<T>(
    capabilities: CrossCuttingCapability[],
    strategyOutput: T,
    context: PluginContext
  ): Promise<{
    artifacts: CrossCuttingArtifacts;
    executed: string[];
    errors: Array<{ plugin: string; error: Error }>;
  }> {
    const artifacts: CrossCuttingArtifacts = {};
    const executed: string[] = [];
    const errors: Array<{ plugin: string; error: Error }> = [];

    // Execute plugins in parallel
    const results = await Promise.allSettled(
      capabilities.map(async (cap) => {
        const plugin = this.plugins.get(cap);
        if (!plugin) {
          return { capability: cap, result: null };
        }

        const result = await plugin.execute(strategyOutput, context);
        return { capability: cap, result };
      })
    );

    // Collect results
    for (const result of results) {
      if (result.status === 'fulfilled') {
        const { capability, result: pluginResult } = result.value;

        if (pluginResult?.success && pluginResult.artifacts) {
          executed.push(capability);
          this.mergeArtifacts(artifacts, pluginResult.artifacts);
        } else if (pluginResult?.error) {
          errors.push({ plugin: capability, error: pluginResult.error });
        }
      } else {
        // Promise rejected
        errors.push({
          plugin: 'unknown',
          error: result.reason as Error,
        });
      }
    }

    return { artifacts, executed, errors };
  }

  /**
   * Check if a capability is available.
   */
  has(capability: CrossCuttingCapability): boolean {
    return this.plugins.has(capability);
  }

  /**
   * List all registered plugins.
   */
  list(): Array<{ name: CrossCuttingCapability; version: string }> {
    return Array.from(this.plugins.values()).map((p) => ({
      name: p.name,
      version: p.version,
    }));
  }

  /**
   * Merge plugin artifacts into combined artifacts.
   */
  private mergeArtifacts(
    target: CrossCuttingArtifacts,
    source: Partial<CrossCuttingArtifacts>
  ): void {
    if (source.diagrams) {
      target.diagrams = [...(target.diagrams ?? []), ...source.diagrams];
    }
    if (source.scripts) {
      target.scripts = [...(target.scripts ?? []), ...source.scripts];
    }
    if (source.configs) {
      target.configs = [...(target.configs ?? []), ...source.configs];
    }
    if (source.workflows) {
      target.workflows = [...(target.workflows ?? []), ...source.workflows];
    }
    if (source.issues) {
      target.issues = [...(target.issues ?? []), ...source.issues];
    }
  }
}

/**
 * Default singleton instance.
 */
export const pluginManager = new PluginManager();
```

### Step 2.4: Implement Framework Router

```typescript
// src/domain/router/framework-router.ts

import { v4 as uuidv4 } from 'uuid';
import { StrategyRegistry, strategyRegistry } from './strategy-registry.js';
import { PluginManager, pluginManager } from './plugin-manager.js';
import type {
  RouterRequest,
  RouterResponse,
  RouterError,
  RouterErrorCode,
  ExecutionSummary,
  OutputApproach,
  CrossCuttingCapability,
} from './types.js';

/**
 * Framework Router - unified entry point for all output generation.
 *
 * The router:
 * 1. Validates the request
 * 2. Routes to the appropriate strategy
 * 3. Executes cross-cutting plugins
 * 4. Formats the output
 * 5. Returns a consistent response
 *
 * @example
 * ```typescript
 * const router = new FrameworkRouter();
 *
 * // Simple execution
 * const result = await router.execute({
 *   approach: 'speckit',
 *   input: {
 *     title: 'My Project',
 *     overview: 'Project description',
 *     objectives: [{ description: 'Build X', priority: 'high' }],
 *     requirements: [{ description: 'Must do Y' }],
 *   },
 * });
 *
 * // With cross-cutting capabilities
 * const result = await router.execute({
 *   approach: 'speckit',
 *   input: { ... },
 *   capabilities: ['diagram', 'workflow', 'issues'],
 * });
 * ```
 */
export class FrameworkRouter {
  constructor(
    private readonly registry: StrategyRegistry = strategyRegistry,
    private readonly plugins: PluginManager = pluginManager
  ) {}

  /**
   * Execute a request through the router.
   *
   * @param request - Router request with approach and input
   * @returns Router response with output and artifacts
   */
  async execute<TInput, TOutput>(
    request: RouterRequest<TInput>
  ): Promise<RouterResponse<TOutput>> {
    const requestId = request.metadata?.requestId ?? uuidv4();
    const startedAt = new Date();

    try {
      // Step 1: Validate approach
      if (!this.registry.has(request.approach)) {
        return this.errorResponse(
          'UNKNOWN_APPROACH',
          `Unknown output approach: ${request.approach}`,
          request.approach,
          requestId,
          startedAt
        );
      }

      // Step 2: Get strategy
      const strategy = this.registry.get<TInput, TOutput>(request.approach);

      // Step 3: Execute strategy
      const strategyResult = await strategy.execute(request.input);

      if (!strategyResult.success) {
        return this.errorResponse(
          'EXECUTION_FAILED',
          strategyResult.error?.message ?? 'Strategy execution failed',
          request.approach,
          requestId,
          startedAt
        );
      }

      // Step 4: Execute plugins (if requested)
      let artifacts = undefined;
      let pluginsExecuted: string[] = [];

      if (request.capabilities && request.capabilities.length > 0) {
        const pluginResult = await this.plugins.execute(
          request.capabilities,
          strategyResult.output,
          {
            approach: request.approach,
            requestId,
            metadata: request.metadata ?? {},
          }
        );

        artifacts = pluginResult.artifacts;
        pluginsExecuted = pluginResult.executed;

        // Log plugin errors but don't fail the request
        if (pluginResult.errors.length > 0) {
          console.warn('Plugin errors:', pluginResult.errors);
        }
      }

      // Step 5: Build response
      const completedAt = new Date();

      return {
        success: true,
        output: strategyResult.output,
        artifacts,
        trace: {
          requestId,
          approach: request.approach,
          startedAt,
          completedAt,
          durationMs: completedAt.getTime() - startedAt.getTime(),
          strategyVersion: strategy.version,
          pluginsExecuted,
          metrics: strategyResult.trace?.metrics ?? {},
        },
      };
    } catch (error) {
      return this.errorResponse(
        'EXECUTION_FAILED',
        error instanceof Error ? error.message : 'Unknown error',
        request.approach,
        requestId,
        startedAt,
        error instanceof Error ? error : undefined
      );
    }
  }

  /**
   * Get available approaches.
   */
  getApproaches(): OutputApproach[] {
    return this.registry.list().map((s) => s.approach);
  }

  /**
   * Get available capabilities.
   */
  getCapabilities(): CrossCuttingCapability[] {
    return this.plugins.list().map((p) => p.name);
  }

  /**
   * Check if an approach is supported.
   */
  supportsApproach(approach: OutputApproach): boolean {
    return this.registry.has(approach);
  }

  /**
   * Create error response.
   */
  private errorResponse<TOutput>(
    code: RouterErrorCode,
    message: string,
    approach: OutputApproach,
    requestId: string,
    startedAt: Date,
    cause?: Error
  ): RouterResponse<TOutput> {
    const completedAt = new Date();

    return {
      success: false,
      error: { code, message, approach, cause },
      trace: {
        requestId,
        approach,
        startedAt,
        completedAt,
        durationMs: completedAt.getTime() - startedAt.getTime(),
        strategyVersion: 'N/A',
        pluginsExecuted: [],
        metrics: {},
      },
    };
  }
}

/**
 * Default singleton instance.
 */
export const frameworkRouter = new FrameworkRouter();
```

### Step 2.5: Create Router Barrel

```typescript
// src/domain/router/index.ts

// Types
export type {
  OutputApproach,
  CrossCuttingCapability,
  RouterRequest,
  RouterResponse,
  RouterError,
  RouterErrorCode,
  CrossCuttingArtifacts,
  DiagramArtifact,
  ScriptArtifact,
  ConfigArtifact,
  WorkflowArtifact,
  IssueArtifact,
  OutputFormat,
  ExecutionSummary,
} from './types.js';

// Registry
export { StrategyRegistry, strategyRegistry } from './strategy-registry.js';

// Plugin Manager
export type { CrossCuttingPlugin, PluginContext, PluginResult } from './plugin-manager.js';
export { PluginManager, pluginManager } from './plugin-manager.js';

// Router
export { FrameworkRouter, frameworkRouter } from './framework-router.js';
```

### Step 2.6: Register Default Strategies

```typescript
// src/domain/router/register-defaults.ts

import { strategyRegistry } from './strategy-registry.js';
import { pluginManager } from './plugin-manager.js';

// Import strategies
import { SpecKitStrategy } from '../../strategies/speckit/speckit-strategy.js';
import { TOGAFStrategy } from '../../strategies/togaf/togaf-strategy.js';
import { ADRStrategy } from '../../strategies/adr/adr-strategy.js';
import { RFCStrategy } from '../../strategies/rfc/rfc-strategy.js';
import { EnterpriseStrategy } from '../../strategies/enterprise/enterprise-strategy.js';
import { SDDStrategy } from '../../strategies/sdd/sdd-strategy.js';
import { ChatStrategy } from '../../strategies/chat/chat-strategy.js';

// Import plugins
import { DiagramPlugin } from '../../plugins/diagram-plugin.js';
import { ShellScriptPlugin } from '../../plugins/shell-script-plugin.js';
import { WorkflowPlugin } from '../../plugins/workflow-plugin.js';
import { IssuesPlugin } from '../../plugins/issues-plugin.js';
import { ConfigPlugin } from '../../plugins/config-plugin.js';
import { PRTemplatePlugin } from '../../plugins/pr-template-plugin.js';

/**
 * Register all default strategies and plugins.
 *
 * Called once at application startup.
 */
export function registerDefaults(): void {
  // Register strategies
  strategyRegistry.register('speckit', () => new SpecKitStrategy(), {
    version: '2.0.0',
    description: 'Generate project specification artifacts (spec.md, plan.md, tasks.md, etc.)',
    singleton: true,
  });

  strategyRegistry.register('togaf', () => new TOGAFStrategy(), {
    version: '2.0.0',
    description: 'Generate TOGAF architecture documentation',
    singleton: true,
  });

  strategyRegistry.register('adr', () => new ADRStrategy(), {
    version: '2.0.0',
    description: 'Generate Architecture Decision Records',
    singleton: true,
  });

  strategyRegistry.register('rfc', () => new RFCStrategy(), {
    version: '2.0.0',
    description: 'Generate Request for Comments documents',
    singleton: true,
  });

  strategyRegistry.register('enterprise', () => new EnterpriseStrategy(), {
    version: '2.0.0',
    description: 'Generate enterprise architecture documentation',
    singleton: true,
  });

  strategyRegistry.register('sdd', () => new SDDStrategy(), {
    version: '2.0.0',
    description: 'Generate Software Design Documents',
    singleton: true,
  });

  strategyRegistry.register('chat', () => new ChatStrategy(), {
    version: '2.0.0',
    description: 'Generate conversational responses',
    singleton: true,
  });

  // Register plugins
  pluginManager.register(new DiagramPlugin());
  pluginManager.register(new ShellScriptPlugin());
  pluginManager.register(new WorkflowPlugin());
  pluginManager.register(new IssuesPlugin());
  pluginManager.register(new ConfigPlugin());
  pluginManager.register(new PRTemplatePlugin());
}
```

---

## 3. Usage in MCP Tools

### Before (Direct Strategy)

```typescript
// ❌ Old pattern - direct strategy instantiation
import { SpecKitStrategy } from '../strategies/speckit-strategy.js';

async function handleSpecKitTool(input: SpecKitInput) {
  const strategy = new SpecKitStrategy();
  const result = await strategy.execute(input);

  return {
    content: [{ type: 'text', text: result.output?.artifacts.spec ?? '' }],
  };
}
```

### After (Using Router)

```typescript
// ✅ New pattern - using Framework Router
import { frameworkRouter } from '../domain/router/index.js';
import type { SpecKitInput, SpecKitOutput } from '../domain/speckit/types.js';

async function handleSpecKitTool(input: SpecKitInput) {
  const result = await frameworkRouter.execute<SpecKitInput, SpecKitOutput>({
    approach: 'speckit',
    input,
    capabilities: ['diagram', 'issues'], // Optional cross-cutting
  });

  if (!result.success) {
    throw new Error(result.error?.message ?? 'Failed to generate spec');
  }

  // Access artifacts
  const spec = result.output?.artifacts.spec ?? '';
  const diagrams = result.artifacts?.diagrams ?? [];

  return {
    content: [
      { type: 'text', text: spec },
      ...diagrams.map(d => ({ type: 'text', text: `\n\n${d.content}` })),
    ],
  };
}
```

---

## 4. Test Coverage

```typescript
// tests/vitest/domain/router/framework-router.spec.ts

import { describe, it, expect, beforeEach, vi } from 'vitest';
import { FrameworkRouter } from '../../../../src/domain/router/framework-router.js';
import { StrategyRegistry } from '../../../../src/domain/router/strategy-registry.js';
import { PluginManager } from '../../../../src/domain/router/plugin-manager.js';
import { BaseStrategy } from '../../../../src/domain/base-strategy/index.js';
import { z } from 'zod';

// Mock strategy for testing
class MockStrategy extends BaseStrategy<{ value: string }, { result: string }> {
  readonly name = 'mock';
  readonly version = '1.0.0';

  constructor() {
    super(z.object({ value: z.string() }));
  }

  protected async executeStrategy(input: { value: string }) {
    return { result: `processed: ${input.value}` };
  }
}

describe('FrameworkRouter', () => {
  let registry: StrategyRegistry;
  let plugins: PluginManager;
  let router: FrameworkRouter;

  beforeEach(() => {
    registry = new StrategyRegistry();
    plugins = new PluginManager();
    router = new FrameworkRouter(registry, plugins);

    // Register mock strategy
    registry.register('speckit' as any, () => new MockStrategy(), {
      version: '1.0.0',
      description: 'Mock strategy for testing',
      singleton: true,
    });
  });

  describe('execute', () => {
    it('should route to correct strategy', async () => {
      const result = await router.execute({
        approach: 'speckit',
        input: { value: 'test' },
      });

      expect(result.success).toBe(true);
      expect(result.output).toEqual({ result: 'processed: test' });
    });

    it('should return error for unknown approach', async () => {
      const result = await router.execute({
        approach: 'unknown' as any,
        input: {},
      });

      expect(result.success).toBe(false);
      expect(result.error?.code).toBe('UNKNOWN_APPROACH');
    });

    it('should include execution trace', async () => {
      const result = await router.execute({
        approach: 'speckit',
        input: { value: 'test' },
      });

      expect(result.trace).toBeDefined();
      expect(result.trace.approach).toBe('speckit');
      expect(result.trace.durationMs).toBeGreaterThanOrEqual(0);
      expect(result.trace.strategyVersion).toBe('1.0.0');
    });

    it('should use provided request ID', async () => {
      const result = await router.execute({
        approach: 'speckit',
        input: { value: 'test' },
        metadata: { requestId: 'custom-id' },
      });

      expect(result.trace.requestId).toBe('custom-id');
    });
  });

  describe('getApproaches', () => {
    it('should list registered approaches', () => {
      const approaches = router.getApproaches();
      expect(approaches).toContain('speckit');
    });
  });

  describe('supportsApproach', () => {
    it('should return true for registered approach', () => {
      expect(router.supportsApproach('speckit')).toBe(true);
    });

    it('should return false for unknown approach', () => {
      expect(router.supportsApproach('unknown' as any)).toBe(false);
    });
  });
});
```

```typescript
// tests/vitest/domain/router/strategy-registry.spec.ts

import { describe, it, expect, beforeEach } from 'vitest';
import { StrategyRegistry } from '../../../../src/domain/router/strategy-registry.js';
import { BaseStrategy } from '../../../../src/domain/base-strategy/index.js';
import { z } from 'zod';

class TestStrategy extends BaseStrategy<{}, {}> {
  static instanceCount = 0;
  readonly name = 'test';
  readonly version = '1.0.0';

  constructor() {
    super(z.object({}));
    TestStrategy.instanceCount++;
  }

  protected async executeStrategy() {
    return {};
  }
}

describe('StrategyRegistry', () => {
  let registry: StrategyRegistry;

  beforeEach(() => {
    registry = new StrategyRegistry();
    TestStrategy.instanceCount = 0;
  });

  it('should register and retrieve strategy', () => {
    registry.register('speckit' as any, () => new TestStrategy(), {
      version: '1.0.0',
      description: 'Test',
    });

    const strategy = registry.get('speckit' as any);
    expect(strategy).toBeInstanceOf(TestStrategy);
  });

  it('should cache singleton strategies', () => {
    registry.register('speckit' as any, () => new TestStrategy(), {
      version: '1.0.0',
      description: 'Test',
      singleton: true,
    });

    registry.get('speckit' as any);
    registry.get('speckit' as any);
    registry.get('speckit' as any);

    expect(TestStrategy.instanceCount).toBe(1);
  });

  it('should create new instances for non-singletons', () => {
    registry.register('speckit' as any, () => new TestStrategy(), {
      version: '1.0.0',
      description: 'Test',
      singleton: false,
    });

    registry.get('speckit' as any);
    registry.get('speckit' as any);
    registry.get('speckit' as any);

    expect(TestStrategy.instanceCount).toBe(3);
  });

  it('should throw on duplicate registration', () => {
    registry.register('speckit' as any, () => new TestStrategy(), {
      version: '1.0.0',
      description: 'Test',
    });

    expect(() => {
      registry.register('speckit' as any, () => new TestStrategy(), {
        version: '1.0.0',
        description: 'Test',
      });
    }).toThrow('already registered');
  });

  it('should throw for unregistered approach', () => {
    expect(() => {
      registry.get('unknown' as any);
    }).toThrow('No strategy registered');
  });
});
```

---

## 5. Acceptance Criteria

| Criterion                                    | Status | Verification          |
| -------------------------------------------- | ------ | --------------------- |
| StrategyRegistry manages all strategies      | ⬜      | Unit tests pass       |
| PluginManager executes cross-cutting plugins | ⬜      | Plugin tests pass     |
| FrameworkRouter routes to correct strategy   | ⬜      | Routing tests pass    |
| Singleton caching works                      | ⬜      | Instance count test   |
| Error handling returns proper codes          | ⬜      | Error tests pass      |
| Execution trace included in response         | ⬜      | Trace assertions pass |
| Default strategies registered at startup     | ⬜      | Integration test      |
| 90% test coverage                            | ⬜      | Coverage report       |

---

## 6. References

| Document                   | Link                                                                               |
| -------------------------- | ---------------------------------------------------------------------------------- |
| T-011: Migrate SpecKit     | [T-011-migrate-speckit.md](/plan-v0.14.x/speckit-v0.14.x-strategic-consolidation/tasks/phase-2-migration/T-011-migrate-speckit.md)          |
| ADR-002: Framework Router  | [adr.md](/plan-v0.14.x/speckit-v0.14.x-strategic-consolidation/adr.md#adr-002)                                                     |
| Current output-strategy.ts | [src/strategies/output-strategy.ts](../../../../src/strategies/output-strategy.ts) |

---

*Task: T-037 | Phase: 3 | Priority: P0*
