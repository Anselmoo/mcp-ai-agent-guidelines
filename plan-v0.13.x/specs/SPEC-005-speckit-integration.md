# SPEC-005: Spec-Kit Integration

> Technical specification for integrating GitHub Spec-Kit methodology with MCP tools

## ðŸ“‹ Document Metadata

| Field         | Value                          |
| ------------- | ------------------------------ |
| Specification | SPEC-005                       |
| Title         | Spec-Kit Integration           |
| Status        | Draft                          |
| Created       | January 2026                   |
| Related ADR   | ADR-001 (OutputStrategy)       |
| Phase         | Phase 4 (Spec-Kit Integration) |

---

## 1. Executive Summary

This specification defines how to integrate GitHub's Spec-Kit (Specification-Driven Development) methodology with MCP tools, enabling automatic generation of `spec.md`, `plan.md`, `tasks.md`, and `progress.md` files that follow the Constitutional AI constraints established in CONSTITUTION.md.

## 2. Background

### 2.1 What is Spec-Kit?

Spec-Kit is GitHub's methodology for AI-assisted development:

```
spec.md â†’ plan.md â†’ tasks.md â†’ progress.md â†’ code
```

| File          | Purpose                    |
| ------------- | -------------------------- |
| `spec.md`     | What the feature should do |
| `plan.md`     | How to implement it        |
| `tasks.md`    | Atomic work items          |
| `progress.md` | Current state tracking     |

### 2.2 Gap Analysis

| Current State                  | Desired State                      |
| ------------------------------ | ---------------------------------- |
| Design-assistant produces ADRs | Should also produce Spec-Kit files |
| No constitutional constraints  | Embedded constraints in generation |
| Manual task creation           | Auto-derived tasks from spec       |
| No progress tracking           | Automated progress updates         |

---

## 3. Goals & Non-Goals

### 3.1 Goals

1. **SpecKit OutputStrategy** â€” New strategy that produces spec.md, plan.md, tasks.md
2. **Constitutional constraints** â€” Embed CONSTITUTION.md rules in generated specs
3. **Task derivation** â€” Auto-generate tasks.md from spec requirements
4. **Progress tracking** â€” Auto-update progress.md based on code changes
5. **Integration with design-assistant** â€” New `speckit` output approach

### 3.2 Non-Goals

- Replacing existing ADR generation
- Full spec.md validation (out of scope)
- GitHub Issues integration (separate feature)

---

## 4. Technical Specification

### 4.1 SpecKit Strategy Implementation

```typescript
// src/strategies/speckit-strategy.ts

import { OutputStrategy, OutputApproach, OutputArtifacts } from './output-strategy.js';

export class SpecKitStrategy implements OutputStrategy {
  readonly approach: OutputApproach = 'speckit';
  readonly crossCutting: CrossCuttingCapability[] = [];

  constructor(
    private constitutionPath?: string
  ) {}

  async render(
    result: DomainResult,
    options: RenderOptions
  ): Promise<OutputArtifacts> {
    // Load constitutional constraints if provided
    const constitution = this.constitutionPath
      ? await this.loadConstitution()
      : null;

    return {
      primary: this.renderSpec(result, constitution),
      additionalDocuments: [
        this.renderPlan(result, constitution),
        this.renderTasks(result),
        this.renderProgress(result),
      ],
    };
  }

  private renderSpec(
    result: DomainResult,
    constitution: Constitution | null
  ): Document {
    return {
      title: 'spec.md',
      content: this.generateSpecContent(result, constitution),
      format: 'markdown',
    };
  }

  private generateSpecContent(
    result: DomainResult,
    constitution: Constitution | null
  ): string {
    const constraintSection = constitution
      ? this.generateConstraintSection(constitution)
      : '';

    return `
# Specification: ${result.title}

## Overview

${result.summary}

## Objectives

${result.objectives?.map((o, i) => `${i + 1}. ${o}`).join('\n')}

## Requirements

### Functional Requirements

${result.functionalRequirements?.map(r => `- [ ] ${r}`).join('\n') || '- [ ] TBD'}

### Non-Functional Requirements

${result.nonFunctionalRequirements?.map(r => `- [ ] ${r}`).join('\n') || '- [ ] TBD'}

${constraintSection}

## Acceptance Criteria

${result.acceptanceCriteria?.map(c => `- [ ] ${c}`).join('\n') || '- [ ] TBD'}

## Out of Scope

${result.outOfScope?.map(o => `- ${o}`).join('\n') || '- None specified'}

---
*Generated by MCP AI Agent Guidelines v0.13.x*
`.trim();
  }

  private generateConstraintSection(constitution: Constitution): string {
    return `
## Constitutional Constraints

The following constraints from CONSTITUTION.md apply:

### Principles
${constitution.principles?.map(p => `- **${p.id}**: ${p.description}`).join('\n')}

### Constraints
${constitution.constraints?.map(c => `- **${c.id}**: ${c.rule}`).join('\n')}

### Architecture Rules
${constitution.architectureRules?.map(r => `- **${r.id}**: ${r.rule}`).join('\n')}
`;
  }

  private renderPlan(
    result: DomainResult,
    constitution: Constitution | null
  ): Document {
    return {
      title: 'plan.md',
      content: `
# Implementation Plan: ${result.title}

## Approach

${result.approach || 'TBD'}

## Phases

${this.generatePhasesSection(result)}

## Dependencies

${result.dependencies?.map(d => `- ${d}`).join('\n') || '- None'}

## Risks

${result.risks?.map(r => `- **${r.name}**: ${r.mitigation}`).join('\n') || '- None identified'}

## Timeline

${this.generateTimelineSection(result)}

---
*Generated by MCP AI Agent Guidelines v0.13.x*
`.trim(),
      format: 'markdown',
    };
  }

  private generatePhasesSection(result: DomainResult): string {
    if (!result.phases?.length) {
      return '- Phase 1: Implementation\n- Phase 2: Testing\n- Phase 3: Documentation';
    }

    return result.phases.map((phase, i) => `
### Phase ${i + 1}: ${phase.name}

${phase.description}

**Deliverables:**
${phase.deliverables?.map(d => `- ${d}`).join('\n')}

**Duration:** ${phase.duration || 'TBD'}
`).join('\n');
  }

  private generateTimelineSection(result: DomainResult): string {
    return `
| Phase | Duration | Start | End |
| ----- | -------- | ----- | --- |
${result.phases?.map((p, i) =>
  `| ${p.name} | ${p.duration || 'TBD'} | ${p.start || 'TBD'} | ${p.end || 'TBD'} |`
).join('\n') || '| TBD | TBD | TBD | TBD |'}
`;
  }

  private renderTasks(result: DomainResult): Document {
    const tasks = this.deriveTasksFromSpec(result);

    return {
      title: 'tasks.md',
      content: `
# Tasks: ${result.title}

## Task List

${tasks.map((t, i) => `
### ${i + 1}. ${t.title}

- **Priority:** ${t.priority}
- **Estimate:** ${t.estimate}
- **Phase:** ${t.phase}
- **Dependencies:** ${t.dependencies?.join(', ') || 'None'}

**Description:** ${t.description}

**Acceptance Criteria:**
${t.acceptanceCriteria?.map(c => `- [ ] ${c}`).join('\n')}
`).join('\n')}

---
*Generated by MCP AI Agent Guidelines v0.13.x*
`.trim(),
      format: 'markdown',
    };
  }

  private deriveTasksFromSpec(result: DomainResult): Task[] {
    const tasks: Task[] = [];

    // Derive tasks from functional requirements
    result.functionalRequirements?.forEach((req, i) => {
      tasks.push({
        title: `Implement: ${this.extractTaskTitle(req)}`,
        description: req,
        priority: i === 0 ? 'high' : 'medium',
        estimate: '2-4 hours',
        phase: result.phases?.[0]?.name || 'Phase 1',
        acceptanceCriteria: [`Requirement met: ${req}`],
      });
    });

    // Derive tasks from acceptance criteria
    result.acceptanceCriteria?.forEach((criterion, i) => {
      tasks.push({
        title: `Verify: ${this.extractTaskTitle(criterion)}`,
        description: `Ensure acceptance criterion is met: ${criterion}`,
        priority: 'medium',
        estimate: '1-2 hours',
        phase: 'Testing',
        acceptanceCriteria: [criterion],
      });
    });

    return tasks;
  }

  private extractTaskTitle(text: string): string {
    // Extract first ~50 characters as task title
    const cleaned = text.replace(/^-\s*\[.\]\s*/, '');
    return cleaned.length > 50 ? cleaned.slice(0, 47) + '...' : cleaned;
  }

  private renderProgress(result: DomainResult): Document {
    return {
      title: 'progress.md',
      content: `
# Progress: ${result.title}

## Status

ðŸŸ¡ **In Progress**

## Summary

| Metric      | Value                                   |
| ----------- | --------------------------------------- |
| Tasks Total | ${result.functionalRequirements?.length |  | 0} |
| Tasks Done  | 0                                       |
| Completion  | 0%                                      |

## Recent Updates

- ${new Date().toISOString().split('T')[0]}: Spec generated

## Blockers

- None

## Next Steps

${result.functionalRequirements?.slice(0, 3).map(r =>
  `- [ ] ${this.extractTaskTitle(r)}`
).join('\n') || '- [ ] TBD'}

---
*Generated by MCP AI Agent Guidelines v0.13.x*
*Last Updated: ${new Date().toISOString()}*
`.trim(),
      format: 'markdown',
    };
  }

  private async loadConstitution(): Promise<Constitution | null> {
    if (!this.constitutionPath) return null;

    try {
      const content = await fs.readFile(this.constitutionPath, 'utf-8');
      return this.parseConstitution(content);
    } catch {
      return null;
    }
  }

  private parseConstitution(content: string): Constitution {
    // Parse CONSTITUTION.md into structured data
    const sections = content.split(/^## /m);

    return {
      principles: this.extractPrinciples(sections),
      constraints: this.extractConstraints(sections),
      architectureRules: this.extractRules(sections, 'Architecture'),
      designPrinciples: this.extractRules(sections, 'Design'),
    };
  }
}
```

### 4.2 Constitution Parser

```typescript
// src/strategies/speckit/constitution-parser.ts

export interface Constitution {
  principles: Principle[];
  constraints: Constraint[];
  architectureRules: Rule[];
  designPrinciples: Rule[];
}

export interface Principle {
  id: string;
  name: string;
  description: string;
}

export interface Constraint {
  id: string;
  rule: string;
  rationale?: string;
}

export interface Rule {
  id: string;
  rule: string;
}

export function parseConstitution(markdown: string): Constitution {
  const result: Constitution = {
    principles: [],
    constraints: [],
    architectureRules: [],
    designPrinciples: [],
  };

  // Parse principles (P1, P2, etc.)
  const principlePattern = /\*\*P(\d+)[:\s-]+([^*]+)\*\*/g;
  let match;
  while ((match = principlePattern.exec(markdown)) !== null) {
    result.principles.push({
      id: `P${match[1]}`,
      name: match[2].trim(),
      description: extractDescription(markdown, match.index),
    });
  }

  // Parse constraints (C1, C2, etc.)
  const constraintPattern = /###\s+C(\d+)[:\s-]+([^\n]+)/g;
  while ((match = constraintPattern.exec(markdown)) !== null) {
    result.constraints.push({
      id: `C${match[1]}`,
      rule: match[2].trim(),
    });
  }

  // Parse architecture rules (AR1, AR2, etc.)
  const arPattern = /\*\*AR(\d+)\*\*[:\s]+([^\n]+)/g;
  while ((match = arPattern.exec(markdown)) !== null) {
    result.architectureRules.push({
      id: `AR${match[1]}`,
      rule: match[2].trim(),
    });
  }

  // Parse design principles (DP1, DP2, etc.)
  const dpPattern = /\*\*DP(\d+)\*\*[:\s]+([^\n]+)/g;
  while ((match = dpPattern.exec(markdown)) !== null) {
    result.designPrinciples.push({
      id: `DP${match[1]}`,
      rule: match[2].trim(),
    });
  }

  return result;
}
```

### 4.3 Integration with Design Assistant

```typescript
// src/tools/design/design-assistant.ts updates

// Add 'speckit' to supported artifact types
export type ArtifactType = 'adr' | 'specification' | 'roadmap' | 'speckit';

// Handle speckit artifact generation
async function handleGenerateArtifacts(
  session: DesignSession,
  artifactTypes: ArtifactType[]
): Promise<GeneratedArtifacts> {
  const artifacts: GeneratedArtifacts = {};

  for (const type of artifactTypes) {
    switch (type) {
      case 'speckit':
        artifacts.speckit = await generateSpecKitArtifacts(session);
        break;
      // ... other cases
    }
  }

  return artifacts;
}

async function generateSpecKitArtifacts(
  session: DesignSession
): Promise<SpecKitArtifacts> {
  const strategy = new SpecKitStrategy(
    path.join(process.cwd(), 'plan-v0.13.x/CONSTITUTION.md')
  );

  const domainResult = convertSessionToDomainResult(session);
  const output = await strategy.render(domainResult, {});

  return {
    spec: output.primary,
    plan: output.additionalDocuments?.find(d => d.title === 'plan.md'),
    tasks: output.additionalDocuments?.find(d => d.title === 'tasks.md'),
    progress: output.additionalDocuments?.find(d => d.title === 'progress.md'),
  };
}
```

### 4.4 Progress Tracker

```typescript
// src/strategies/speckit/progress-tracker.ts

export class ProgressTracker {
  private progressPath: string;

  constructor(progressPath: string) {
    this.progressPath = progressPath;
  }

  /**
   * Update progress based on completed tasks
   */
  async updateProgress(completedTasks: string[]): Promise<void> {
    const progress = await this.loadProgress();

    for (const taskId of completedTasks) {
      progress.completedTasks.add(taskId);
    }

    progress.lastUpdated = new Date();
    progress.completion = this.calculateCompletion(progress);

    await this.saveProgress(progress);
  }

  /**
   * Get current progress status
   */
  async getStatus(): Promise<ProgressStatus> {
    const progress = await this.loadProgress();

    return {
      total: progress.totalTasks,
      completed: progress.completedTasks.size,
      percentage: progress.completion,
      lastUpdated: progress.lastUpdated,
      blockers: progress.blockers,
    };
  }

  /**
   * Auto-update progress from Git commits
   */
  async syncFromGit(commitMessages: string[]): Promise<void> {
    const taskPattern = /(?:close[sd]?|fix(?:e[sd])?|resolve[sd]?)\s+#(\d+)/gi;
    const completedTasks: string[] = [];

    for (const message of commitMessages) {
      let match;
      while ((match = taskPattern.exec(message)) !== null) {
        completedTasks.push(match[1]);
      }
    }

    if (completedTasks.length > 0) {
      await this.updateProgress(completedTasks);
    }
  }
}
```

---

## 5. Workflow Integration

### 5.1 Design-to-SpecKit Workflow

```typescript
// Usage example
const designAssistant = new DesignAssistant();

// Start design session
await designAssistant.handle({
  action: 'start-session',
  sessionId: 'feature-x',
  config: {
    goal: 'Implement new feature X',
    context: 'Adding search functionality',
    requirements: ['Fast search', 'Fuzzy matching', 'Result highlighting'],
  },
});

// Advance through phases...

// Generate Spec-Kit artifacts
const artifacts = await designAssistant.handle({
  action: 'generate-artifacts',
  sessionId: 'feature-x',
  artifactTypes: ['speckit'],
});

// Result:
// - spec.md with constitutional constraints
// - plan.md with implementation phases
// - tasks.md with derived tasks
// - progress.md for tracking
```

### 5.2 MCP Tool Integration

```typescript
// New tool: speckit-generator
server.tool(
  'speckit-generator',
  'Generate Spec-Kit files (spec.md, plan.md, tasks.md) from requirements. BEST FOR: New features, refactoring projects, sprint planning. OUTPUTS: 4 markdown files following GitHub Spec-Kit methodology.',
  speckitSchema,
  GENERATION_TOOL_ANNOTATIONS,
  async (args) => {
    const strategy = new SpecKitStrategy(args.constitutionPath);
    const artifacts = await strategy.render(args.requirements, args.options);
    return formatArtifactsResponse(artifacts);
  }
);
```

---

## 6. Constitutional Constraint Validation

### 6.1 Spec Validator

```typescript
// src/strategies/speckit/spec-validator.ts

export class SpecValidator {
  constructor(private constitution: Constitution) {}

  /**
   * Validate spec against constitutional constraints
   */
  validate(spec: ParsedSpec): ValidationResult {
    const violations: Violation[] = [];

    // Check principles
    for (const principle of this.constitution.principles) {
      if (!this.checkPrinciple(spec, principle)) {
        violations.push({
          type: 'principle',
          id: principle.id,
          message: `Spec may violate principle ${principle.id}: ${principle.name}`,
        });
      }
    }

    // Check constraints
    for (const constraint of this.constitution.constraints) {
      if (!this.checkConstraint(spec, constraint)) {
        violations.push({
          type: 'constraint',
          id: constraint.id,
          message: `Spec violates constraint ${constraint.id}: ${constraint.rule}`,
        });
      }
    }

    return {
      valid: violations.length === 0,
      violations,
      warnings: this.generateWarnings(spec),
    };
  }

  private checkPrinciple(spec: ParsedSpec, principle: Principle): boolean {
    // Implementation-specific checks
    switch (principle.id) {
      case 'P1': // OutputStrategy
        return spec.objectives?.some(o =>
          o.includes('output') || o.includes('format')
        ) || true;
      case 'P2': // Tool Harmonization
        return !spec.requirements?.some(r =>
          r.includes('duplicate') || r.includes('overlap')
        );
      default:
        return true;
    }
  }

  private checkConstraint(spec: ParsedSpec, constraint: Constraint): boolean {
    // Implementation-specific checks
    switch (constraint.id) {
      case 'C1': // Spec-Driven Development
        return spec.acceptanceCriteria?.length > 0;
      case 'C2': // Backward Compatibility
        return !spec.requirements?.some(r =>
          r.includes('breaking') || r.includes('remove')
        );
      case 'C3': // Feature Flag Guard
        return spec.requirements?.some(r =>
          r.includes('feature flag') || r.includes('gradual rollout')
        ) || true;
      default:
        return true;
    }
  }
}
```

---

## 7. Testing Strategy

### 7.1 Strategy Tests

```typescript
// tests/vitest/strategies/speckit-strategy.spec.ts
describe('SpecKitStrategy', () => {
  it('generates all four files', async () => {
    const strategy = new SpecKitStrategy();
    const result = await strategy.render(mockDomainResult, {});

    expect(result.primary.title).toBe('spec.md');
    expect(result.additionalDocuments).toHaveLength(3);
    expect(result.additionalDocuments?.map(d => d.title)).toEqual([
      'plan.md', 'tasks.md', 'progress.md'
    ]);
  });

  it('includes constitutional constraints when provided', async () => {
    const strategy = new SpecKitStrategy('./test-constitution.md');
    const result = await strategy.render(mockDomainResult, {});

    expect(result.primary.content).toContain('Constitutional Constraints');
    expect(result.primary.content).toContain('P1');
  });

  it('derives tasks from requirements', async () => {
    const strategy = new SpecKitStrategy();
    const result = await strategy.render({
      ...mockDomainResult,
      functionalRequirements: ['Add search', 'Add filters'],
    }, {});

    const tasksDoc = result.additionalDocuments?.find(d => d.title === 'tasks.md');
    expect(tasksDoc?.content).toContain('Implement: Add search');
    expect(tasksDoc?.content).toContain('Implement: Add filters');
  });
});
```

### 7.2 Validator Tests

```typescript
// tests/vitest/strategies/speckit/spec-validator.spec.ts
describe('SpecValidator', () => {
  it('detects backward compatibility violations', () => {
    const validator = new SpecValidator(mockConstitution);
    const spec: ParsedSpec = {
      requirements: ['Remove old API endpoint'],
    };

    const result = validator.validate(spec);

    expect(result.valid).toBe(false);
    expect(result.violations).toContainEqual(
      expect.objectContaining({ id: 'C2' })
    );
  });
});
```

---

## 8. Success Criteria

| Criterion                    | Target    | Measurement                          |
| ---------------------------- | --------- | ------------------------------------ |
| SpecKit strategy implemented | Complete  | All 4 files generated                |
| Constitution parsing         | 100%      | All principles/constraints extracted |
| Task derivation              | Automatic | Tasks generated from requirements    |
| Validation                   | Complete  | All constraints checked              |
| Integration                  | Complete  | Works with design-assistant          |
| Test coverage                | 90%+      | Vitest report                        |

---

## 9. References

- [GitHub Spec Kit](https://github.com/github/spec-kit) (internal)
- [CONSTITUTION.md](../CONSTITUTION.md)
- [ADR-001: OutputStrategy Pattern](../adrs/ADR-001-output-strategy-pattern.md)
- [Memory: v013_output_strategy_layer](serena://memories/v013_output_strategy_layer)

---

*Specification Created: January 2026*
*Status: Draft â€” Awaiting Review*
