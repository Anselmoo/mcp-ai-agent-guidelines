/**
 * Tests for ADRStrategy
 *
 * @module tests/strategies/adr-strategy
 */

import { describe, expect, it } from "vitest";
import type { PromptResult } from "../../../src/domain/prompting/types.js";
import { ADRStrategy } from "../../../src/strategies/adr-strategy.js";
import { OutputApproach } from "../../../src/strategies/output-strategy.js";

/**
 * ADRSessionState interface for testing (matches ADR-specific interface in adr-strategy.ts)
 */
interface ADRSessionState {
	id: string;
	phase?: string;
	context?: Record<string, unknown>;
	config?: {
		goal?: string;
		context?: Record<string, unknown>;
		requirements?: unknown;
	};
	artifacts?: Record<string, unknown>;
	metadata?: {
		title?: string;
		decision?: string;
		positiveConsequences?: string[];
		negativeConsequences?: string[];
		neutralConsequences?: string[];
	};
}

describe("ADRStrategy", () => {
	describe("constructor and properties", () => {
		it("should have ADR approach", () => {
			const strategy = new ADRStrategy();
			expect(strategy.approach).toBe(OutputApproach.ADR);
		});

		it("should have readonly approach property", () => {
			const strategy = new ADRStrategy();
			// TypeScript readonly is compile-time only, verify it's set correctly
			expect(strategy.approach).toBe(OutputApproach.ADR);
		});
	});

	describe("supports() method", () => {
		it("should support SessionState", () => {
			const strategy = new ADRStrategy();
			expect(strategy.supports("SessionState")).toBe(true);
		});

		it("should support PromptResult", () => {
			const strategy = new ADRStrategy();
			expect(strategy.supports("PromptResult")).toBe(true);
		});

		it("should not support unsupported types", () => {
			const strategy = new ADRStrategy();
			expect(strategy.supports("ScoringResult")).toBe(false);
			expect(strategy.supports("UnknownType")).toBe(false);
			expect(strategy.supports("")).toBe(false);
		});
	});

	describe("render() - SessionState", () => {
		it("should render SessionState with full metadata to ADR format", () => {
			const strategy = new ADRStrategy();
			const result: SessionState = {
				id: "session-123",
				phase: "architecture",
				config: {
					goal: "Implement microservices architecture",
				},
				metadata: {
					title: "Adopt Microservices Architecture",
					decision:
						"We will adopt a microservices architecture for our platform",
					positiveConsequences: [
						"Better scalability",
						"Independent deployments",
						"Technology flexibility",
					],
					negativeConsequences: [
						"Increased operational complexity",
						"Network latency overhead",
					],
					neutralConsequences: ["Team reorganization required"],
				},
			};

			const artifacts = strategy.render(result);

			expect(artifacts.primary.format).toBe("markdown");
			expect(artifacts.primary.name).toMatch(
				/^ADR-\d{4}-adopt-microservices-architecture\.md$/,
			);
			expect(artifacts.primary.content).toContain("# ADR-");
			expect(artifacts.primary.content).toContain(
				"Adopt Microservices Architecture",
			);
			expect(artifacts.primary.content).toContain("## Status");
			expect(artifacts.primary.content).toContain("**Proposed**");
			expect(artifacts.primary.content).toContain("## Context");
			expect(artifacts.primary.content).toContain("## Decision");
			expect(artifacts.primary.content).toContain(
				"We will adopt a microservices architecture for our platform",
			);
			expect(artifacts.primary.content).toContain("## Consequences");
			expect(artifacts.primary.content).toContain("### Positive");
			expect(artifacts.primary.content).toContain("- Better scalability");
			expect(artifacts.primary.content).toContain("- Independent deployments");
			expect(artifacts.primary.content).toContain("- Technology flexibility");
			expect(artifacts.primary.content).toContain("### Negative");
			expect(artifacts.primary.content).toContain(
				"- Increased operational complexity",
			);
			expect(artifacts.primary.content).toContain("- Network latency overhead");
			expect(artifacts.primary.content).toContain("### Neutral");
			expect(artifacts.primary.content).toContain(
				"- Team reorganization required",
			);
			expect(artifacts.primary.content).toContain("## References");
			expect(artifacts.primary.content).toContain("Session ID: session-123");
			expect(artifacts.primary.content).toContain(
				"*ADR generated by design-assistant*",
			);
		});

		it("should render SessionState with minimal metadata", () => {
			const strategy = new ADRStrategy();
			const result: SessionState = {
				id: "session-456",
			};

			const artifacts = strategy.render(result);

			expect(artifacts.primary.content).toContain("# ADR-");
			expect(artifacts.primary.content).toContain("Untitled Decision");
			expect(artifacts.primary.content).toContain("- To be determined");
		});

		it("should use config.goal as title when metadata.title is missing", () => {
			const strategy = new ADRStrategy();
			const result: SessionState = {
				id: "session-789",
				config: {
					goal: "Migrate to Cloud Infrastructure",
				},
			};

			const artifacts = strategy.render(result);

			expect(artifacts.primary.content).toContain(
				"Migrate to Cloud Infrastructure",
			);
			expect(artifacts.primary.name).toMatch(/migrate-to-cloud-infrastructure/);
		});

		it("should extract context from config", () => {
			const strategy = new ADRStrategy();
			const result: SessionState = {
				id: "session-context",
				config: {
					goal: "Improve API Performance",
					context: {
						currentLoad: "1000 req/s",
						targetLoad: "10000 req/s",
					},
				},
			};

			const artifacts = strategy.render(result);

			expect(artifacts.primary.content).toContain("Improve API Performance");
			expect(artifacts.primary.content).toContain("currentLoad");
			expect(artifacts.primary.content).toContain("targetLoad");
		});

		it("should include phase in references when present", () => {
			const strategy = new ADRStrategy();
			const result: SessionState = {
				id: "session-phase",
				phase: "implementation",
				config: {
					goal: "Test Goal",
				},
			};

			const artifacts = strategy.render(result);

			expect(artifacts.primary.content).toContain("Phase: implementation");
		});

		it("should include artifacts in references when present", () => {
			const strategy = new ADRStrategy();
			const result: SessionState = {
				id: "session-artifacts",
				artifacts: {
					spec: "specification.md",
					diagram: "architecture.mmd",
				},
			};

			const artifacts = strategy.render(result);

			expect(artifacts.primary.content).toContain(
				"Related artifacts: spec, diagram",
			);
		});

		it("should handle empty consequences arrays", () => {
			const strategy = new ADRStrategy();
			const result: SessionState = {
				id: "session-empty",
				metadata: {
					positiveConsequences: [],
					negativeConsequences: [],
					neutralConsequences: [],
				},
			};

			const artifacts = strategy.render(result);

			expect(artifacts.primary.content).toContain(
				"### Positive\n\n- To be determined",
			);
			expect(artifacts.primary.content).toContain(
				"### Negative\n\n- To be determined",
			);
			expect(artifacts.primary.content).toContain(
				"### Neutral\n\n- To be determined",
			);
		});
	});

	describe("render() - PromptResult", () => {
		it("should render PromptResult to ADR format", () => {
			const strategy = new ADRStrategy();
			const result: PromptResult = {
				sections: [
					{
						title: "API Gateway Decision",
						body: "We need to select an API gateway solution",
						level: 1,
					},
					{
						title: "Context",
						body: "Our microservices need a unified entry point for external clients",
						level: 2,
					},
					{
						title: "Decision",
						body: "We will use Kong as our API gateway",
						level: 2,
					},
					{
						title: "Consequences",
						body: "Improved security and rate limiting",
						level: 2,
					},
				],
				metadata: {
					complexity: 60,
					tokenEstimate: 300,
					sections: 4,
					techniques: ["zero-shot"],
					requirementsCount: 2,
					issuesCount: 0,
				},
			};

			const artifacts = strategy.render(result);

			expect(artifacts.primary.format).toBe("markdown");
			expect(artifacts.primary.name).toMatch(
				/^ADR-\d{4}-api-gateway-decision\.md$/,
			);
			expect(artifacts.primary.content).toContain("# ADR-");
			expect(artifacts.primary.content).toContain("API Gateway Decision");
			expect(artifacts.primary.content).toContain("## Status");
			expect(artifacts.primary.content).toContain("## Context");
			expect(artifacts.primary.content).toContain("unified entry point");
			expect(artifacts.primary.content).toContain("## Decision");
			expect(artifacts.primary.content).toContain("We will use Kong");
			expect(artifacts.primary.content).toContain(
				"*ADR generated by hierarchical-prompt-builder*",
			);
		});

		it("should handle PromptResult with missing ADR sections", () => {
			const strategy = new ADRStrategy();
			const result: PromptResult = {
				sections: [
					{
						title: "Some Title",
						body: "Some content without ADR structure",
						level: 1,
					},
				],
				metadata: {
					complexity: 30,
					tokenEstimate: 100,
					sections: 1,
					techniques: ["few-shot"],
					requirementsCount: 0,
					issuesCount: 0,
				},
			};

			const artifacts = strategy.render(result);

			expect(artifacts.primary.content).toContain("No context provided");
			expect(artifacts.primary.content).toContain("Decision to be documented");
			expect(artifacts.primary.content).toContain("- To be determined");
		});

		it("should include metadata when includeMetadata is true", () => {
			const strategy = new ADRStrategy();
			const result: PromptResult = {
				sections: [
					{
						title: "Test Decision",
						body: "Test content",
						level: 1,
					},
				],
				metadata: {
					complexity: 50,
					tokenEstimate: 250,
					sections: 1,
					techniques: ["chain-of-thought", "few-shot"],
					requirementsCount: 3,
					issuesCount: 1,
				},
			};

			const artifacts = strategy.render(result, { includeMetadata: true });

			expect(artifacts.primary.content).toContain(
				"Technique: chain-of-thought, few-shot",
			);
			expect(artifacts.primary.content).toContain("Tokens: ~250");
		});

		it("should not include metadata by default", () => {
			const strategy = new ADRStrategy();
			const result: PromptResult = {
				sections: [
					{
						title: "Test",
						body: "Content",
						level: 1,
					},
				],
				metadata: {
					complexity: 40,
					tokenEstimate: 200,
					sections: 1,
					techniques: ["zero-shot"],
					requirementsCount: 0,
					issuesCount: 0,
				},
			};

			const artifacts = strategy.render(result);

			expect(artifacts.primary.content).not.toContain("Technique:");
			expect(artifacts.primary.content).not.toContain("Tokens:");
		});
	});

	describe("render() - error handling", () => {
		it("should throw error for unsupported result type", () => {
			const strategy = new ADRStrategy();
			const invalidResult = {
				someField: "value",
			};

			expect(() =>
				strategy.render(invalidResult as ADRSessionState | PromptResult),
			).toThrow("Unsupported domain result type for ADRStrategy");
		});

		it("should throw error for null result", () => {
			const strategy = new ADRStrategy();

			expect(() =>
				strategy.render(null as unknown as ADRSessionState | PromptResult),
			).toThrow("Unsupported domain result type for ADRStrategy");
		});

		it("should throw error for undefined result", () => {
			const strategy = new ADRStrategy();

			expect(() =>
				strategy.render(undefined as unknown as ADRSessionState | PromptResult),
			).toThrow("Unsupported domain result type for ADRStrategy");
		});
	});

	describe("ADR numbering", () => {
		it("should generate 4-digit ADR numbers", () => {
			const strategy = new ADRStrategy();
			const result: SessionState = {
				id: "session-number",
			};

			const artifacts = strategy.render(result);

			const match = artifacts.primary.name.match(/^ADR-(\d{4})-/);
			expect(match).not.toBeNull();
			expect(match?.[1]).toHaveLength(4);
		});

		it("should generate unique ADR numbers for different renders", () => {
			const strategy = new ADRStrategy();
			const result: SessionState = {
				id: "session-unique",
			};

			const artifacts1 = strategy.render(result);
			// Small delay to ensure different timestamp
			const artifacts2 = strategy.render(result);

			// Numbers might be same if executed in same millisecond, but format should be correct
			expect(artifacts1.primary.name).toMatch(/^ADR-\d{4}-/);
			expect(artifacts2.primary.name).toMatch(/^ADR-\d{4}-/);
		});
	});

	describe("slugify", () => {
		it("should convert title to lowercase slug", () => {
			const strategy = new ADRStrategy();
			const result: SessionState = {
				id: "session-slug",
				metadata: {
					title: "Adopt Microservices Architecture",
				},
			};

			const artifacts = strategy.render(result);

			expect(artifacts.primary.name).toContain(
				"adopt-microservices-architecture",
			);
		});

		it("should replace spaces with hyphens", () => {
			const strategy = new ADRStrategy();
			const result: SessionState = {
				id: "session-spaces",
				metadata: {
					title: "Multiple Word Title Here",
				},
			};

			const artifacts = strategy.render(result);

			expect(artifacts.primary.name).toContain("multiple-word-title-here");
		});

		it("should remove special characters", () => {
			const strategy = new ADRStrategy();
			const result: SessionState = {
				id: "session-special",
				metadata: {
					title: "Title with @#$% Special! Characters?",
				},
			};

			const artifacts = strategy.render(result);

			expect(artifacts.primary.name).toContain("title-with-special-characters");
			expect(artifacts.primary.name).not.toContain("@");
			expect(artifacts.primary.name).not.toContain("#");
			expect(artifacts.primary.name).not.toContain("!");
			expect(artifacts.primary.name).not.toContain("?");
		});

		it("should truncate long titles to 50 characters", () => {
			const strategy = new ADRStrategy();
			const longTitle =
				"This is a very long title that exceeds fifty characters and should be truncated appropriately";
			const result: SessionState = {
				id: "session-long",
				metadata: {
					title: longTitle,
				},
			};

			const artifacts = strategy.render(result);

			const slugPart =
				artifacts.primary.name.match(/ADR-\d{4}-(.*?)\.md$/)?.[1];
			expect(slugPart).toBeDefined();
			expect(slugPart!.length).toBeLessThanOrEqual(50);
		});

		it("should handle titles with consecutive spaces", () => {
			const strategy = new ADRStrategy();
			const result: SessionState = {
				id: "session-spaces",
				metadata: {
					title: "Title   with    multiple     spaces",
				},
			};

			const artifacts = strategy.render(result);

			expect(artifacts.primary.name).toContain("title-with-multiple-spaces");
			expect(artifacts.primary.name).not.toContain("--");
		});
	});

	describe("output artifacts structure", () => {
		it("should return OutputArtifacts with primary document only", () => {
			const strategy = new ADRStrategy();
			const result: SessionState = {
				id: "session-structure",
			};

			const artifacts = strategy.render(result);

			expect(artifacts.primary).toBeDefined();
			expect(artifacts.secondary).toBeUndefined();
			expect(artifacts.crossCutting).toBeUndefined();
		});

		it("should have correct document format", () => {
			const strategy = new ADRStrategy();
			const result: SessionState = {
				id: "session-format",
			};

			const artifacts = strategy.render(result);

			expect(artifacts.primary.format).toBe("markdown");
			expect(artifacts.primary.name).toMatch(/\.md$/);
			expect(typeof artifacts.primary.content).toBe("string");
		});
	});

	describe("date formatting", () => {
		it("should include current date in ISO format", () => {
			const strategy = new ADRStrategy();
			const result: SessionState = {
				id: "session-date",
			};

			const artifacts = strategy.render(result);

			const dateRegex = /\d{4}-\d{2}-\d{2}/;
			expect(artifacts.primary.content).toMatch(dateRegex);
		});
	});

	describe("Michael Nygard format compliance", () => {
		it("should include all required ADR sections in correct order", () => {
			const strategy = new ADRStrategy();
			const result: SessionState = {
				id: "session-format",
				metadata: {
					title: "Test Decision",
				},
			};

			const artifacts = strategy.render(result);
			const content = artifacts.primary.content;

			// Check section order
			const statusIndex = content.indexOf("## Status");
			const contextIndex = content.indexOf("## Context");
			const decisionIndex = content.indexOf("## Decision");
			const consequencesIndex = content.indexOf("## Consequences");
			const referencesIndex = content.indexOf("## References");

			expect(statusIndex).toBeGreaterThan(-1);
			expect(contextIndex).toBeGreaterThan(statusIndex);
			expect(decisionIndex).toBeGreaterThan(contextIndex);
			expect(consequencesIndex).toBeGreaterThan(decisionIndex);
			expect(referencesIndex).toBeGreaterThan(consequencesIndex);
		});

		it("should split consequences into Positive, Negative, and Neutral", () => {
			const strategy = new ADRStrategy();
			const result: SessionState = {
				id: "session-consequences",
			};

			const artifacts = strategy.render(result);

			expect(artifacts.primary.content).toContain("### Positive");
			expect(artifacts.primary.content).toContain("### Negative");
			expect(artifacts.primary.content).toContain("### Neutral");
		});
	});
});
