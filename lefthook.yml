# Lefthook Git hooks configuration
# Fast Git hooks manager for maintaining code quality and security

# Global settings
min_version: 1.5.0

# Pre-commit hooks - run before commit is created
pre-commit:
  parallel: true
  commands:
    # ----------------------------- ğŸ”’ Security Tools ---------------------------- #
    gitleaks:
      tags: [security]
      # Moved the long embedded script into a dedicated executable script for clarity and maintainability
      run: ./lefthook/security_check.sh
      fail_text: "ğŸ”’ Gitleaks detected secrets in staged files"

    # --------------------------- ğŸ” Code Quality Tools -------------------------- #
    biome-check:
      tags: [format, lint]
      glob: "*.{js,jsx,ts,tsx,cjs,cts,mjs,mts,json,jsonc}"
      run: npx biome check --write --files-ignore-unknown=true --no-errors-on-unmatched {staged_files}
      stage_fixed: true
      fail_text: "ğŸŸ¨ Biome formatting/linting issues found"

    typescript-check:
      tags: [types]
      glob: "*.{ts,tsx}"
      run: npm run generate:models:internal && npx tsc --noEmit
      fail_text: "ğŸ”· TypeScript type checking failed"

    # ----------------------------- ğŸ“ File Validation ---------------------------- #
    yaml-lint:
      tags: [format, lint, validate]
      glob: "*.{yml,yaml}"
      run: |
        if command -v yamllint >/dev/null 2>&1; then
          yamllint {staged_files}
        else
          echo "âš ï¸  yamllint not found, skipping YAML validation"
          echo "   Install: brew install yamllint (macOS) or pip install yamllint"
        fi
      fail_text: "ğŸ“„ YAML syntax errors found"

    json-lint:
      tags: [format, lint, validate]
      glob: "*.{json,jsonc}"
      run: |
        for file in {staged_files}; do
          if [ -f "$file" ]; then
            # Use Node.js built-in JSON parser for validation
            node -e "try { JSON.parse(require('fs').readFileSync('$file', 'utf8')); } catch(e) { console.error('Invalid JSON in $file:', e.message); process.exit(1); }" || exit 1
          fi
        done
      fail_text: "ğŸ“„ JSON syntax errors found"

    # --------------------------- ğŸ“„ Documentation Checks -------------------------- #
    docs-quality:
      tags: [docs, validate]
      glob: "docs/**/*.{md,svg}"
      run: npm run docs:lint:warn-only
      fail_text: "ğŸ“„ Documentation quality issues found (naming, headers, footers, SVG)"

    docs-svg-fix:
      tags: [docs, format]
      glob: "docs/**/*.svg"
      run: npm run docs:fix-svg
      stage_fixed: true
      fail_text: "ğŸ¨ SVG dark mode visibility issues fixed"

    # ----------------------------- ğŸ“ File Quality ---------------------------- #
    trailing-whitespace:
      tags: [format]
      glob: "*.{js,jsx,ts,tsx,py,md,yml,yaml,json,txt}"
      run: |
        for file in {staged_files}; do
          if [ -f "$file" ]; then
            perl -i -pe 's/[ \t]+$//' "$file"
          fi
        done
      stage_fixed: true
      fail_text: "ğŸ§¹ Trailing whitespace removed"

    end-of-file-fixer:
      tags: [format]
      glob: "*.{js,jsx,ts,tsx,py,md,yml,yaml,json,txt}"
      run: |
        for file in {staged_files}; do
          if [ -f "$file" ] && [ -s "$file" ] && [ "$(tail -c1 "$file")" != "" ]; then
            echo "" >> "$file"
          fi
        done
      stage_fixed: true
      fail_text: "ğŸ§¹ End-of-file issues fixed"

    # ----------------------------- ğŸ¤– Agent Cost Prevention ---------------------------- #
    # These checks prevent common issues that cause costly agent reruns

    esm-imports-check:
      tags: [validate, imports, agent-cost-saver]
      glob: "*.{ts,tsx}"
      run: |
        failed=0
        for file in {staged_files}; do
          if [ -f "$file" ]; then
            # Check for relative imports without .js extension
            if grep -n "from ['\"]\.\.?/" "$file" | grep -v "\.js['\"]" > /dev/null 2>&1; then
              echo "âŒ ERROR: Relative imports must end with .js extension in $file"
              echo "   Example: import { foo } from './bar.js'"
              grep -n "from ['\"]\.\.?/" "$file" | grep -v "\.js['\"]" | while read line; do
                echo "   Line: $line"
              done
              failed=1
            fi
          fi
        done
        exit $failed
      fail_text: "âŒ Relative imports must use .js extensions (ESM requirement) - This causes agent reruns!"

    typescript-any-check:
      tags: [types, strict, agent-cost-saver]
      glob: "*.{ts,tsx}"
      run: |
        failed=0
        for file in {staged_files}; do
          if [ -f "$file" ]; then
            # Check for 'any' types (but allow in test files)
            if [[ ! "$file" =~ \.spec\.ts$ ]] && [[ ! "$file" =~ \.test\.ts$ ]]; then
              if grep -n ": any" "$file" > /dev/null 2>&1; then
                echo "âš ï¸  WARNING: Avoid using 'any' types in $file"
                echo "   Use proper TypeScript types instead"
                grep -n ": any" "$file" | while read line; do
                  echo "   Line: $line"
                done
                # Don't fail, just warn
              fi
            fi
          fi
        done
        exit 0
      fail_text: "âš ï¸  Found 'any' types - use proper TypeScript types"

    test-coverage-check:
      tags: [test, validate, agent-cost-saver]
      glob: "src/**/*.{ts,tsx}"
      run: |
        missing_tests=""
        for file in {staged_files}; do
          # Skip index.ts files
          if [[ "$file" == *"/index.ts" ]]; then
            continue
          fi

          # Convert src/tools/foo.ts â†’ tests/vitest/tools/foo.spec.ts
          test_file=$(echo "$file" | sed 's|^src/|tests/vitest/|' | sed 's|\.ts$|.spec.ts|')

          if [ ! -f "$test_file" ]; then
            echo "âš ï¸  WARNING: No test file found for $file"
            echo "   Expected: $test_file"
            echo "   Create tests to maintain 90% coverage requirement"
            missing_tests="$missing_tests\n  - $file â†’ $test_file"
          fi
        done

        if [ -n "$missing_tests" ]; then
          echo ""
          echo "ğŸ“ Missing test files:$missing_tests"
          echo ""
          echo "   Tip: Run 'npm run test:coverage:vitest' to check coverage"
        fi
        exit 0
      fail_text: "âš ï¸  Some source files are missing tests"

    console-log-check:
      tags: [quality, agent-cost-saver]
      glob: "src/**/*.{ts,tsx,js,jsx}"
      run: |
        failed=0
        for file in {staged_files}; do
          if [ -f "$file" ]; then
            # Check for console.log (should use logger instead)
            if grep -n "console\.log\|console\.error\|console\.warn" "$file" > /dev/null 2>&1; then
              echo "âš ï¸  WARNING: Avoid using console.log in $file"
              echo "   Use 'import { logger } from \"../shared/logger.js\"' instead"
              grep -n "console\." "$file" | while read line; do
                echo "   Line: $line"
              done
              # Don't fail, just warn for now
            fi
          fi
        done
        exit 0
      fail_text: "âš ï¸  Found console.log - use logger instead"

    # ----------------------------- ğŸ§ª Test Validation (CRITICAL) ---------------------------- #
    # Prevent committing code that will fail CI tests - MOST EXPENSIVE ISSUE!

    quick-test-check:
      tags: [test, validate, agent-cost-saver, critical]
      glob: "*.{ts,tsx}"
      run: |
        # Only run if test files or source files are staged
        if echo "{staged_files}" | grep -E "(src/|tests/).*\.tsx?$" > /dev/null 2>&1; then
          echo "ğŸ§ª Running quick test validation..."
          echo "   (This prevents expensive CI failures!)"

          # Build only when source implementation files (non-test) have changed
          if echo "{staged_files}" | grep -E "src/.*\.tsx?$" | grep -Ev "\.(test|spec)\.tsx?$" > /dev/null 2>&1; then
            echo "ğŸ“¦ Building project (source implementation changes detected)..."
            npm run build --silent || {
              echo "âŒ Build failed! Fix build errors before committing."
              exit 1
            }
          else
            echo "ğŸ“¦ Skipping build (no source implementation changes detected)."
          fi

          # Run only affected tests (fast check)
          echo "ğŸ§ª Running affected tests..."
          npm run test:vitest -- --run --bail=1 || {
            echo ""
            echo "âŒ TESTS FAILED! This would fail in CI."
            echo "   Fix test failures before committing to avoid:"
            echo "   - Expensive CI reruns (\$0.10+ per failure)"
            echo "   - Delayed merge time"
            echo "   - Agent rerun costs"
            echo ""
            echo "   Run 'npm run test:vitest' to see details"
            exit 1
          }

          echo "âœ… Tests passed! Safe to commit."
        fi
      fail_text: "ğŸ§ª Tests failed - fix before committing to avoid expensive CI failures!"

# Pre-push hooks - run before push to remote
# NOTE: These are WARNING-ONLY hooks. CI is the final quality gate.
# See issue #832 for optimization roadmap
pre-push:
  commands:
    # ----------------------------- ğŸ”’ Security Warnings ---------------------------- #
    dependency-audit:
      tags: [security, audit]
      run: |
        echo "ğŸ”’ Checking for dependency vulnerabilities..."
        if ! npm audit --omit=dev --audit-level=moderate; then
          echo ""
          echo "âš ï¸  WARNING: Dependency vulnerabilities detected"
          echo "   Run 'npm audit' for details"
          echo "   Run 'npm audit fix' to auto-fix when possible"
          echo ""
          echo "   Note: This is a warning only. CI will enforce security checks."
        fi
        exit 0  # Always succeed (warning only)
      fail_text: "âš ï¸  Dependency vulnerabilities detected (warning only)"

    # DISABLED: Redundant with pre-commit quick-test-check
    # Pre-commit already runs tests on staged files, no need to run full suite
    # See issue #832 for pre-commit/pre-push duplication analysis
    # test-all:
    #   tags: [test, critical]
    #   run: npm run test:all
    #   fail_text: "ğŸ§ª Tests failed"

    # DISABLED: Redundant with pre-commit typescript-check
    # Pre-commit already runs type-checking on staged files
    # See issue #832 for pre-commit/pre-push duplication analysis
    # quality-check:
    #   tags: [quality]
    #   run: npm run quality
    #   fail_text: "âš¡ Quality checks failed"

# Output settings
output:
  - execution
  - success
